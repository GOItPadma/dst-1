
R Under development (unstable) (2018-04-05 r74542) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "dst"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('dst')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("addTobca")
> ### * addTobca
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: addTobca
> ### Title: Add some elements of 0 mass to an existing mass function
> ### Aliases: addTobca
> 
> ### ** Examples
> 
>  
> y <- bca(f=matrix(c(1,0,0,1,1,1),nrow=2, byrow = TRUE), 
+ m=c(0.6, 0.4),  cnames = c("a", "b", "c"), varnb=1)
> addTobca(y, matrix(c(0,1,0,0,0,1, 0,1,1), nrow=3, byrow = TRUE))
$con
[1] 0

$tt
      a b c
b     0 1 0
c     0 0 1
b + c 0 1 1
a     1 0 0
frame 1 1 1

$spec
     specnb mass
[1,]      1  0.0
[2,]      2  0.0
[3,]      3  0.0
[4,]      4  0.6
[5,]      5  0.4

$infovar
     varnb size
[1,]     1    3

$infovaluenames
$infovaluenames$v1
[1] "a" "b" "c"


$inforel
     relnb depth
[1,]     0     0

attr(,"class")
[1] "list"    "bcaspec"
> x <- bca(f=matrix(c(0,1,1,1,1,0,1,1,1),nrow=3, 
+ byrow = TRUE), m=c(0.2,0.5, 0.3), 
+ cnames =c("a", "b", "c"), varnb=1)
> xy <- dsrwon(x,y)
> xy1 <- addTobca(nzdsr(xy), matrix(c(0,1,0,0,0,1), nrow=2, byrow = TRUE))
> xy1
$con
[1] 0.12

$tt
      a b c
b     0 1 0
c     0 0 1
a     1 0 0
b + c 0 1 1
a + b 1 1 0
frame 1 1 1

$spec
     specnb       mass
[1,]      1 0.00000000
[2,]      2 0.00000000
[3,]      3 0.54545455
[4,]      4 0.09090909
[5,]      5 0.22727273
[6,]      6 0.13636364

$infovar
     varnb size
[1,]     1    3

$infovaluenames
$infovaluenames$v1
[1] "a" "b" "c"


$inforel
     relnb depth
[1,]     0     1

attr(,"class")
[1] "list"    "bcaspec"
> addTobca(x, f = diag(1,  ncol(x$tt) ) ) # add all singletons
$con
[1] 0

$tt
      a b c
a     1 0 0
b     0 1 0
c     0 0 1
b + c 0 1 1
a + b 1 1 0
frame 1 1 1

$spec
     specnb mass
[1,]      1  0.0
[2,]      2  0.0
[3,]      3  0.0
[4,]      4  0.2
[5,]      5  0.5
[6,]      6  0.3

$infovar
     varnb size
[1,]     1    3

$infovaluenames
$infovaluenames$v1
[1] "a" "b" "c"


$inforel
     relnb depth
[1,]     0     0

attr(,"class")
[1] "list"    "bcaspec"
> 
> 
> 
> cleanEx()
> nameEx("bca")
> ### * bca
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bca
> ### Title: Basic chance assignment mass function
> ### Aliases: bca bpa
> 
> ### ** Examples
> 
> f<- t(matrix(c(1,0,1,1),ncol=2))
> m<- c(.9,.1)
> cnames <- c("yes","no")
> bca(f, m)
$con
[1] 0

$tt
      col1 col2
col1     1    0
frame    1    1

$spec
     specnb mass
[1,]      1  0.9
[2,]      2  0.1

$infovar
     varnb size
[1,]     0    2

$infovaluenames
$infovaluenames$v1
[1] "col1" "col2"


$inforel
     relnb depth
[1,]     0     0

attr(,"class")
[1] "list"    "bcaspec"
> bca(f, m, cnames)
$con
[1] 0

$tt
      yes no
yes     1  0
frame   1  1

$spec
     specnb mass
[1,]      1  0.9
[2,]      2  0.1

$infovar
     varnb size
[1,]     0    2

$infovaluenames
$infovaluenames$v1
[1] "yes" "no" 


$inforel
     relnb depth
[1,]     0     0

attr(,"class")
[1] "list"    "bcaspec"
> bca(f, m, cnames, varnb = 1)
$con
[1] 0

$tt
      yes no
yes     1  0
frame   1  1

$spec
     specnb mass
[1,]      1  0.9
[2,]      2  0.1

$infovar
     varnb size
[1,]     1    2

$infovaluenames
$infovaluenames$v1
[1] "yes" "no" 


$inforel
     relnb depth
[1,]     0     0

attr(,"class")
[1] "list"    "bcaspec"
> x <- bca(f=matrix(c(0,1,1,1,1,0,1,1,1),nrow=3, 
+ byrow = TRUE), m=c(0.2,0.5, 0.3), 
+ cnames =c("a", "b", "c"), varnb = 1)
> y <- bca(f=matrix(c(1,0,0,1,1,1),nrow=2, 
+ byrow = TRUE), m=c(0.6,0.4), 
+ cnames =c("a", "b", "c"),infovarnames = "y", varnb = 1)
> frame <- bca(matrix(c(1,1,1), nrow=1), m=1, cnames = c("a","b","c"))
> 
> 
> 
> cleanEx()
> nameEx("bcaRel")
> ### * bcaRel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bcaRel
> ### Title: Representation of a mass function in a product space
> ### Aliases: bcaRel
> 
> ### ** Examples
> 
> # A logical implication rule
> # A typical relation between two variables in the context of expert systems is the
> # logical implication \code{(a -> b)}. Let us suppose
> # that \code{a} stands for \code{Rain: {yes, no}} and \code{b} stands for
> # \code{RoadWorks: {yes, no}}. From experience,
> # I am 75 % sure that there will be RoadWorks if there is no rain.
> ## 1. The tt table of the logical implication
>  ttrwf <- matrix(c(0,1,1,0,1,0,1,0,1,0,0,1,1,1,1,1),
+  nrow=4, byrow = TRUE, 
+  dimnames = list(NULL, c("rWdy", "rWdn", "Ry", "Rn")) )
>  ## The mass distribution
>  specrw <-  matrix(c(1,1,1,2,0.75,0.75,0.75,0.25), ncol = 2, 
+  dimnames = list(NULL, c("specnb", "mass"))) 
>  ## Variables numbers and sizes
>  inforw <- matrix(c(4,5,2,2), ncol = 2, 
+  dimnames = list(NULL, c("varnb", "size")) )
> bcaRel(tt = ttrwf, spec = specrw, infovar = inforw,
+  infovarnames = c("RdWorks", "Rain"), relnb = 6)
$con
[1] 0

$tt
                            rWdy Ry rWdy Rn rWdn Ry rWdn Rn
rWdy Ry + rWdy Rn + rWdn Ry    TRUE    TRUE    TRUE   FALSE
frame                          TRUE    TRUE    TRUE    TRUE

$spec
     specnb mass
          1 0.75
mass      2 0.25

$infovar
     varnb size
[1,]     4    2
[2,]     5    2

$infovaluenames
$infovaluenames$RdWorks
[1] "rWdy" "rWdn"

$infovaluenames$Rain
[1] "Ry" "Rn"


$inforel
     relnb depth
[1,]     6     2

attr(,"class")
[1] "list"    "bcaspec"
>  
> 
> 
> 
> cleanEx()
> nameEx("belplau")
> ### * belplau
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: belplau
> ### Title: Calculation of the degrees of Belief and Plausibility
> ### Aliases: belplau
> 
> ### ** Examples
> 
> x <- bca(f=matrix(c(0,1,1,1,1,0,1,1,1),nrow=3, 
+ byrow = TRUE), m=c(0.2,0.5, 0.3), 
+ cnames =c("a", "b", "c"), infovarnames = "x", varnb = 1)
> belplau(x)
      Belief Plausibility Plty Ratio
b + c    0.2            1       1.25
a + b    0.5            1       2.00
frame    1.0            1        Inf
> y <- bca(f=matrix(c(1,0,0,1,1,1),nrow=2, 
+ byrow = TRUE), m=c(0.6, 0.4),  
+ cnames = c("a", "b", "c"),  infovarnames = "y", varnb = 1)
> belplau(nzdsr(dsrwon(x,y)))
          Belief Plausibility Plty Ratio
a     0.54545455    0.9090909        2.0
b + c 0.09090909    0.4545455        0.5
a + b 0.77272727    1.0000000        4.4
frame 1.00000000    1.0000000        Inf
> print("compare all elementary events")
[1] "compare all elementary events"
> xy1 <- addTobca(nzdsr(dsrwon(x,y)), 
+ matrix(c(0,1,0,0,0,1), nrow=2, byrow = TRUE))
> belplau(xy1) 
          Belief Plausibility Plty Ratio
b     0.00000000    0.4545455  0.4545455
c     0.00000000    0.2272727  0.2272727
a     0.54545455    0.9090909  2.0000000
b + c 0.09090909    0.4545455  0.5000000
a + b 0.77272727    1.0000000  4.4000000
frame 1.00000000    1.0000000        Inf
> 
> 
> 
> cleanEx()
> nameEx("decode")
> ### * decode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: decode
> ### Title: Find the value in base 10 of a number coded in another base
> ### Aliases: decode aplDecode
> 
> ### ** Examples
> 
> decode(c(2,2,2,2), c(1,0,1,1)) #   Find the base 10 value of the base 2 number 1011.
[1] 11
> decode(2, c(1,0,1,1))  # left argument is extended to vector c(2,2,2,2)
[1] 11
> decode(c(365,24,60), c(2,1,57)) # transform 2 days 1 h 57 min in minutes
[1] 2997
> decode(c(365,24,60), c(1,57))   # right vector extended
[1] 117
> decode(c(24,60), c(2,1,57))     # left vector extended
[1] 2997
> decode(1.5, c(1,2,3)) # polynomial 1*x^2 +2*x +3 evaluated at x=1.5
[1] 8.25
> 
> 
> 
> cleanEx()
> nameEx("dotprod")
> ### * dotprod
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dotprod
> ### Title: Generalized inner product of two matrices
> ### Aliases: dotprod
> 
> ### ** Examples
> 
> print("Standard matrix product")
[1] "Standard matrix product"
> x <- y <- matrix(c(1:6), nrow = 2, byrow = TRUE)
> dotprod(x, t(y), g = "+", f = "*")  ## same as x %*% t(y)
     [,1] [,2]
[1,]   14   32
[2,]   32   77
> print("Find some data x2 in the rows of a larger matrix y2")
[1] "Find some data x2 in the rows of a larger matrix y2"
> x2 <- matrix(c(1,0,0,1,1,1), nrow = 2, byrow = TRUE)
> y2 <- matrix(c(1,0,0,0,1,0,1,1,0,0,1,1,1,1,1), 
+ nrow = 5, byrow = TRUE)
> (1:nrow(y2)) * dotprod(x2, t(y2), g = "&", f = "==")
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    0    0    0
[2,]    0    0    0    0    5
> 
> print("Find some names in a long list")
[1] "Find some names in a long list"
> team_names <- matrix(c("Patrick", "Dole", "Amanda",
+  "Dole", "Robert", "Calvin", "Alvina", "Klein",
+   "Robert", "Gariepy", "Nellie", "Arcand"),
+    ncol = 2, byrow = TRUE)
> colnames(team_names) <- c("First_name", "Last_name")
> print("Where in the list are the person with first name Robert and where are the Doles?")
[1] "Where in the list are the person with first name Robert and where are the Doles?"
> BobandDoles <- matrix(c("Robert", "", "", "Dole"),
+  ncol = 2, byrow = TRUE)
> dotprod(team_names, t(BobandDoles),g="|",f="==") * (1:nrow(team_names))
     [,1] [,2]
[1,]    0    1
[2,]    0    2
[3,]    3    0
[4,]    0    0
[5,]    5    0
[6,]    0    0
> 
> 
> 
> cleanEx()
> nameEx("doubles")
> ### * doubles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: doubles
> ### Title: Remove duplicate rows in a two-dimensional table
> ### Aliases: doubles
> 
> ### ** Examples
> 
> td0<-matrix(c(rep(c(1,0,1),times=3),0,0,1,1,1,1, 1,1,1),ncol=3,byrow=TRUE)
> (doubles(td0))
     [,1] [,2] [,3]
[1,]    1    0    1
[2,]    0    0    1
[3,]    1    1    1
> td1<-matrix(c(rep(c(1,0,1),times=3),0,0,1,1,1,1),ncol=3,byrow=TRUE)
> (doubles(td1))
     [,1] [,2] [,3]
[1,]    1    0    1
[2,]    0    0    1
[3,]    1    1    1
> td2<-matrix(c(1:3, 1:3,4:6,1:3),nrow=4,byrow=TRUE)
> (doubles(td2))
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
> td3<-matrix(c("d","e","f", rep(c("a","b","cc"),times=3),"g","h","i"),nrow=5,byrow=TRUE)
> (doubles(td3))
     [,1] [,2] [,3]
[1,] "d"  "e"  "f" 
[2,] "a"  "b"  "cc"
[3,] "g"  "h"  "i" 
> td4<-matrix(as.logical(td1),nrow=5,byrow=TRUE)
> (doubles(td4))
      [,1]  [,2]  [,3]
[1,]  TRUE  TRUE  TRUE
[2,] FALSE  TRUE FALSE
[3,] FALSE FALSE FALSE
> 
> 
> 
> cleanEx()
> nameEx("dsrwon")
> ### * dsrwon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dsrwon
> ### Title: Combination of two mass functions
> ### Aliases: dsrwon
> 
> ### ** Examples
> 
> x1 <- bca(f=matrix(c(0,1,1,1,1,0,1,1,1),nrow=3, 
+ byrow = TRUE), m=c(0.2,0.5, 0.3), 
+ cnames =c("a", "b", "c"),  
+ infovarnames = "x", varnb=1)
> x2 <- bca(f=matrix(c(1,0,0,1,1,1),nrow=2, 
+ byrow = TRUE), m=c(0.6, 0.4),  
+ cnames = c("a", "b", "c"),  
+ infovarnames = "x", varnb = 1)
> dsrwon(x1,x2)
$con
[1] 0.12

$tt
      a b c
ø     0 0 0
a     1 0 0
b + c 0 1 1
a + b 1 1 0
frame 1 1 1

$spec
     specnb mass
[1,]      1 0.12
[2,]      2 0.48
[3,]      3 0.08
[4,]      4 0.20
[5,]      5 0.12

$infovar
     varnb size
[1,]     1    3

$infovaluenames
$infovaluenames$x
[1] "a" "b" "c"


$inforel
     relnb depth
[1,]     0     0

$I12
      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]
[1,]  TRUE FALSE FALSE FALSE FALSE FALSE
[2,] FALSE  TRUE  TRUE FALSE FALSE FALSE
[3,] FALSE FALSE FALSE  TRUE FALSE FALSE
[4,] FALSE FALSE FALSE FALSE  TRUE FALSE
[5,] FALSE FALSE FALSE FALSE FALSE  TRUE

$sort_order
[1] 1 2 3 4 5

attr(,"class")
[1] "list"    "bcaspec"
> 
> 
> 
> cleanEx()
> nameEx("elim")
> ### * elim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: elim
> ### Title: Reduction of a relation
> ### Aliases: elim
> 
> ### ** Examples
> 
>  
> wr_tt <- matrix(c(0,1,rep(0,5),rep(c(1,0),2),1,1,0,1,0,
+ rep(1,3),0,1,0,rep(1,6)), ncol=4, byrow = TRUE)
> colnames(wr_tt) <- c("rWdy Ry", "rWdy Rn", "rWdn Ry", "rWdn Rn")
>  wr_spec = matrix(c(1:7, 0.0476, 0.7619, 0.1905, 0,0,0,0), 
+  ncol = 2, dimnames = list(NULL, c("specnb", "mass"))) 
>  wr_infovar = matrix(c(4,5,2,2), ncol = 2, 
+  dimnames = list(NULL, c("varnb", "size")) )
>  wr_rel <- list(tt=wr_tt, con=0.16, spec=wr_spec,
+   infovar=wr_infovar, 
+   infovaluenames= list(Rain=c("Ry", "Rn"), RdWorks=c("rWdy", "rWdn") ))
>  class(wr_rel)="bcaspec"
>  elim(wr_rel, xnb = 5)
$con
[1] 0.16

$tt
      Ry Rn
Ry     1  0
Rn     0  1
frame  1  1

$spec
     specnb   mass
[1,]      1 0.0476
[2,]      2 0.7619
[3,]      3 0.1905

$infovar
     varnb size
[1,]     4    2

$infovaluenames
$infovaluenames$Rain
[1] "Ry" "Rn"


$inforel
     relnb depth
[1,]     0     0

attr(,"class")
[1] "list"    "bcaspec"
>  elim(wr_rel, xnb = 4)
$con
[1] 0.16

$tt
      rWdy rWdn
rWdn     0    1
rWdy     1    0
frame    1    1

$spec
     specnb mass
[1,]      1    1
[2,]      2    0
[3,]      3    0

$infovar
     varnb size
[1,]     5    2

$infovaluenames
$infovaluenames$RdWorks
[1] "rWdy" "rWdn"


$inforel
     relnb depth
[1,]     0     0

attr(,"class")
[1] "list"    "bcaspec"
>  
>  mrt_tt <- matrix(c(1,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,1,0,1,rep(1,4)), 
+  ncol=4, byrow = TRUE)
> colnames(mrt_tt) <- c("t6", "f6", "t8", "f8")
>  mrt_spec = matrix(c(1,1,1,2,2,2,3, 0.1, 0.1, 0.1, 0.7,0.7,0.7,0.2), 
+  ncol = 2, dimnames = list(NULL, c("specnb", "mass"))) 
>  mrt_infovar =matrix(c(6,8,2,2), ncol = 2, 
+  dimnames = list(NULL, c("varnb", "size")) )
>  mrt_rel <- bcaRel(tt=mrt_tt, spec=mrt_spec, 
+  infovar=mrt_infovar, 
+  infovarnames= c("Maintenance", "Repair") )
>  elim(mrt_rel, xnb = 6)
$con
[1] 0

$tt
      t8 f8
frame  1  1

$spec
     specnb mass
[1,]      1    1

$infovar
     varnb size
[1,]     8    2

$infovaluenames
$infovaluenames$Repair
[1] "t8" "f8"


$inforel
     relnb depth
[1,]     0     2

attr(,"class")
[1] "list"    "bcaspec"
>  elim(mrt_rel, xnb = 8)
$con
[1] 0

$tt
      t6 f6
frame  1  1

$spec
     specnb mass
[1,]      1    1

$infovar
     varnb size
[1,]     6    2

$infovaluenames
$infovaluenames$Maintenance
[1] "t6" "f6"


$inforel
     relnb depth
[1,]     0     2

attr(,"class")
[1] "list"    "bcaspec"
> 
> 
> 
> cleanEx()
> nameEx("encode")
> ### * encode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: encode
> ### Title: Convert a value to its representation in another chosen base
> ### Aliases: encode aplEncode
> 
> ### ** Examples
> 
> encode(c(2,2,2,2), 11)  # find the base 2 representation of number 11
[1] 1 0 1 1
> encode(c(365,24,60), 2997) # convert 2997 minutes to days-hrs-min.
[1]  2  1 57
> 
> 
> 
> cleanEx()
> nameEx("extmin")
> ### * extmin
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extmin
> ### Title: Extension of a relation
> ### Aliases: extmin
> 
> ### ** Examples
> 
> # making an empty reference relation with mass(frame) = 1 and
> # extending a bca to it.
> init_tt= matrix(rep(1,10),nrow=1, 
+ dimnames =list(NULL, c("0", "1", "2", "3", 
+ "true", "false", "foul", "fair", "true", "false")) )
>  init_spec <- matrix(c(1,1), ncol = 2, 
+  dimnames = list(NULL, c("specnb", "mass")))
>  init_info <- matrix(c(2,4,5,6,4,2,2,2), ncol = 2,
+   dimnames = list(NULL, c("varnb", "size")) )
>  relRef <- bcaRel(tt = init_tt, spec = init_spec,
+   infovar = init_info, 
+   infovarnames = c("Delay", "Loading", "Forecast", "Maintenance"),
+   relnb = 0)
>  # a bcaspec defined on one variable
>  l_rel <- bca(f=matrix(c(1,0,1,0,1,1), ncol=2), 
+  m=c(0.3,0.5,0.2), cnames=c("true", "false"), 
+  infovar=matrix(c(4,2), ncol = 2, 
+  dimnames = list(NULL, c("varnb", "size"))), 
+  infovarnames= c("Loading"), 
+  inforel= matrix(c(7,1), ncol = 2, 
+  dimnames = list(NULL, c("relnb", "depth"))))
>  z <- extmin(l_rel, relRef)
>  prmatrix(t(z$tt), collab = rep("", nrow(z$tt)))
                        
0 true foul true   1 0 1
0 true foul false  1 0 1
0 true fair true   1 0 1
0 true fair false  1 0 1
0 false foul true  0 1 1
0 false foul false 0 1 1
0 false fair true  0 1 1
0 false fair false 0 1 1
1 true foul true   1 0 1
1 true foul false  1 0 1
1 true fair true   1 0 1
1 true fair false  1 0 1
1 false foul true  0 1 1
1 false foul false 0 1 1
1 false fair true  0 1 1
1 false fair false 0 1 1
2 true foul true   1 0 1
2 true foul false  1 0 1
2 true fair true   1 0 1
2 true fair false  1 0 1
2 false foul true  0 1 1
2 false foul false 0 1 1
2 false fair true  0 1 1
2 false fair false 0 1 1
3 true foul true   1 0 1
3 true foul false  1 0 1
3 true fair true   1 0 1
3 true fair false  1 0 1
3 false foul true  0 1 1
3 false foul false 0 1 1
3 false fair true  0 1 1
3 false fair false 0 1 1
>  
> 
> 
> 
> cleanEx()
> nameEx("inters")
> ### * inters
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inters
> ### Title: Intersection of two tables of propositions
> ### Aliases: inters
> 
> ### ** Examples
> 
> mx<-matrix(c(0,1,0,0,1,1,1,1,1),nrow=3, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c")))
>  rownames(mx) <- nameRows(mx)
> my<-matrix(c(0,0,1,1,1,1),nrow=2, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c")))
>  rownames(my) <- nameRows(my)
> inters(mx,my)
, , c

      a b c
b     0 0 0
b + c 0 0 1
frame 0 0 1

, , frame

      a b c
b     0 1 0
b + c 0 1 1
frame 1 1 1

> b1 <- c(FALSE, TRUE, TRUE)
> b2 <- c(TRUE, TRUE, FALSE)
> names(b1) <- names(b2) <- c("c1","c2","c3")
> inters(b1,b2)
, , y

  c1 c2 c3
x  0  1  0

> x3<-matrix(c(1,1,0,1), ncol=2, dimnames=list(NULL, c("a","b")))
> y3<-matrix(c(0,1,1,1), ncol=2, dimnames=list(NULL, c("a","b")))
> inters(x3,y3)
, , 1

     a b
[1,] 0 0
[2,] 0 1

, , 2

     a b
[1,] 1 0
[2,] 1 1

> x4 <-matrix(c(1,0,1,1,1,1,1,1),nrow=2, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c","d")))
> y4 <-matrix(c(1,0,0,1,1,1,1,1),nrow=2, byrow = TRUE, dimnames = list(NULL, c("a", "b", "c","d")))
> inters(x4,y4)
, , 1

     a b c d
[1,] 1 0 0 1
[2,] 1 0 0 1

, , 2

     a b c d
[1,] 1 0 1 1
[2,] 1 1 1 1

> 
> 
> 
> cleanEx()
> nameEx("nameRows")
> ### * nameRows
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nameRows
> ### Title: Using the column names of a matrix to construct names for the
> ###   rows
> ### Aliases: nameRows
> 
> ### ** Examples
> 
> f <- matrix(c(0,0,0,1,0,0,0,0,1,1,0,1,1,1,1),ncol=3, byrow = TRUE)
> colnames(f) <- c("A","B","C")
> rownames(f) <-nameRows(f)
> f
      A B C
ø     0 0 0
A     1 0 0
C     0 0 1
A + C 1 0 1
frame 1 1 1
> f2 <- matrix(c(0,0,0,1,0,0,0,0,1,1,0,1),ncol=3, byrow = TRUE)
> colnames(f2) <- c("A2","B2","C2")
> rownames(f2) <-nameRows(f2) 
> f2
        A2 B2 C2
ø        0  0  0
A2       1  0  0
C2       0  0  1
A2 + C2  1  0  1
> 
> 
> 
> cleanEx()
> nameEx("nzdsr")
> ### * nzdsr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nzdsr
> ### Title: Normalization of a bca mass function
> ### Aliases: nzdsr
> 
> ### ** Examples
> 
> x1 <- bca(f=matrix(c(1,0,1,1),nrow=2, byrow = TRUE), 
+ m=c(0.9,0.1), cnames =c("yes", "no"),
+ infovarnames = "x", varnb = 1)
> x2 <- bca(f=matrix(c(0,1,1,1),nrow=2, byrow = TRUE), 
+ m=c(0.5,0.5), cnames =c("yes", "no"), 
+ infovarnames = "x", varnb = 1)
> print("combination of x1 and x2")
[1] "combination of x1 and x2"
> x1x2 <- dsrwon(x1,x2)
> nzdsr(x1x2) 
$con
[1] 0.45

$tt
      yes no
no      0  1
yes     1  0
frame   1  1

$spec
     specnb       mass
[1,]      1 0.09090909
[2,]      2 0.81818182
[3,]      3 0.09090909

$infovar
     varnb size
[1,]     1    2

$infovaluenames
$infovaluenames$x
[1] "yes" "no" 


$inforel
     relnb depth
[1,]     0     1

attr(,"class")
[1] "list"    "bcaspec"
> 
> print("normalization of a bca definition.")
[1] "normalization of a bca definition."
> y2 <- bca(f=matrix(c(0,0,0,1,0,0,1,1,1),nrow=3, 
+ byrow = TRUE), m=c(0.2,0.5,0.3), 
+ cnames =c("a", "b", "c"), varnb = 1)
> nzdsr(y2)  
$con
[1] 0

$tt
      a b c
a     1 0 0
frame 1 1 1

$spec
     specnb  mass
[1,]      1 0.625
[2,]      2 0.375

$infovar
     varnb size
[1,]     1    3

$infovaluenames
$infovaluenames$v1
[1] "a" "b" "c"


$inforel
     relnb depth
[1,]     0     1

attr(,"class")
[1] "list"    "bcaspec"
> 
> 
> 
> cleanEx()
> nameEx("plautrans")
> ### * plautrans
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plautrans
> ### Title: Plausibility transformation of the singletons of a frame
> ### Aliases: plautrans
> 
> ### ** Examples
> 
>  
> x <- bca(f=matrix(c(0,1,1,1,1,0,1,1,1),nrow=3, 
+ byrow = TRUE), m=c(0.2,0.5, 0.3), 
+ cnames =c("a", "b", "c"), 
+ infovarnames = "x", varnb = 1)
> plautrans(x)
  a b c    trplau
a 1 0 0 0.3478261
b 0 1 0 0.4347826
c 0 0 1 0.2173913
> 
> 
> 
> cleanEx()
> nameEx("productSpace")
> ### * productSpace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: productSpace
> ### Title: Product space representation of a relation
> ### Aliases: productSpace
> 
> ### ** Examples
> 
>  ttfw= matrix(c(1,0,1,0,0,1,0,1,1,1,1,1),nrow=3,
+   byrow = TRUE, 
+   dimnames =list(NULL, c("foul", "fair", "foul", "fair")) )
>  specfw = c(1,1,2) 
>  infovarfw =matrix(c(5,7,2,2), ncol = 2, 
+  dimnames = list(NULL, c("varnb", "size")) )
> productSpace(tt=ttfw, specnb=specfw, infovar=infovarfw)
     foul foul foul fair fair foul fair fair
[1,]      TRUE     FALSE     FALSE      TRUE
[2,]      TRUE      TRUE      TRUE      TRUE
> 
> 
> 
> cleanEx()
> nameEx("shape")
> ### * shape
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: shape
> ### Title: Obtain dimensions of an array or length of a vector with a
> ###   single command
> ### Aliases: shape aplShape
> 
> ### ** Examples
> 
> shape(array(c(1:6), c(2,3)))
[1] 2 3
> shape(c("a", "b"))
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("tabresul")
> ### * tabresul
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tabresul
> ### Title: Prepare a table of results
> ### Aliases: tabresul
> 
> ### ** Examples
> 
>  
> x <- bca(f=matrix(c(0,1,1,1,1,0,1,1,1),nrow=3, 
+ byrow = TRUE), m=c(0.2,0.5, 0.3), 
+ cnames =c("a", "b", "c"), 
+ infovarnames = "x", varnb = 1)
> y <- bca(f=matrix(c(1,0,0,1,1,1),nrow=2, 
+ byrow = TRUE), m=c(0.6, 0.4),  
+ cnames = c("a", "b", "c"), infovarnames = "y", varnb = 1)
> xy <- dsrwon(x,y)
> xyNorm <- nzdsr(xy)
> tabresul(xyNorm) 
$mbp
      a b c       mass     Belief Plausibility Plty Ratio
a     1 0 0 0.54545455 0.54545455    0.9090909        2.0
b + c 0 1 1 0.09090909 0.09090909    0.4545455        0.5
a + b 1 1 0 0.22727273 0.77272727    1.0000000        4.4
frame 1 1 1 0.13636364 1.00000000    1.0000000        Inf

$Conflict
[1] 0.12

> ## print("Show all elementary events")
> xy1 <- addTobca(nzdsr(dsrwon(x,y)), 
+ matrix(c(0,1,0,0,0,1), 
+ nrow=2, byrow = TRUE))
> tabresul(xy1)
$mbp
      a b c       mass     Belief Plausibility Plty Ratio
b     0 1 0 0.00000000 0.00000000    0.4545455  0.4545455
c     0 0 1 0.00000000 0.00000000    0.2272727  0.2272727
a     1 0 0 0.54545455 0.54545455    0.9090909  2.0000000
b + c 0 1 1 0.09090909 0.09090909    0.4545455  0.5000000
a + b 1 1 0 0.22727273 0.77272727    1.0000000  4.4000000
frame 1 1 1 0.13636364 1.00000000    1.0000000        Inf

$Conflict
[1] 0.12

> ## print("Remove focal elements with 0 mass")
> tabresul(xy1, removeZeroes = TRUE)
$mbp
      a b c       mass     Belief Plausibility Plty Ratio
a     1 0 0 0.54545455 0.54545455    0.9090909        2.0
b + c 0 1 1 0.09090909 0.09090909    0.4545455        0.5
a + b 1 1 0 0.22727273 0.77272727    1.0000000        4.4
frame 1 1 1 0.13636364 1.00000000    1.0000000        Inf

$Conflict
[1] 0.12

> print("Retain singletons only")
[1] "Retain singletons only"
> tabresul(xy1, singletonsOnly = TRUE)
$mbp
  a b c      mass    Belief Plausibility Plty Ratio
b 0 1 0 0.0000000 0.0000000    0.4545455  0.4545455
c 0 0 1 0.0000000 0.0000000    0.2272727  0.2272727
a 1 0 0 0.5454545 0.5454545    0.9090909  2.0000000

$Conflict
[1] 0.12

> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.307 0.032 0.358 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
